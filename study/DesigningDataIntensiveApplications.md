## 데이터 중심 애플리케이션 설계 리뷰, 정리

### 1장 : 데이터 시스템의 기초 : 신뢰성(reliability), 확장성(scalability), 유지보수성(maintainability)
- data-intensive : CPU성능은 문제 X, 데이터의 양, 데이터의 복잡도, 데이터의 변화 속도
한 가지 데이터 시스템으로 애플리케이션의 광범위한 요구사항을 모두 만족시킬 수 없다. <br>
대신 작업(work)를 단일 도구에서 효율적으로 수행할 수 있는 태스크(task)로 나누고 다양한 도구들은 애플리케이션 코드를 이용해 서로 연결한다
- 신뢰성(Reliability) : 하드웨어나 소프트웨어 결함, 인적 오류 같은 역경에 직면하더라도 시스템은 지속적으로 올바르게(원하는 성능 수준에서 정확한 기능을 수행) 동작해야 한다.
- 확장성(Scalability) : 시스템의 데이터 양, 트래픽 양, 복잡도가 증가하면서 이를 처리할 수 있는 적절한 방법이 있어야 한다.
- 유지보수성(Maintainability) : 모든 사용자가 시스템 상에서 생산적으로 작업(현재 작업을 유지보수하고 새로운 사용 사례를 시스템에 적용하는 엔지니어링과 운영)할 수 있게 해야 한다.
<br>

#### 신뢰성
- 결함(fault) : 잘못될 수 있는 일
  - 일반적으로, 사양에서 벗어난 시스템의 한 구성 요소
- 내결함성(fault-tolerant) : 결함을 예측하고 대처할 수 있는 능력
- 장애(failure) : 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우
  - 결함으로 인해 장애가 발생하지 않도록 내결함성 구조 설계
예방책이 해결책보다 좋은 경우(해결책이 없는 경우 등) : 보안 문제<br>
해결책이 있는 결함 유형
  - 하드웨어 결함
    - 특징
      - 늘상 발생
      - 하드디스크의 평균장애시간(MTTF : mean time to failure) : 10~50년
      - 10000개의 디스크로 구성된 저장 클러스터는 평균적으로 하루 한 개 디스크가 죽는다
    - 해결책
      - 하드웨어 구성 요소에 중복(redundancy) 추가
        - 디스크 : RAID 구성(Redundant Array of Inexpensive/Independent Disk)
        - 서버 : 이중 전원 디바이스, 핫스왑(작동 중에 구성 요소 교체) 가능한 CPU
        - 데이터센터 : 건전지, 예비 전원용 디젤 발전기
        - 최근까지 단일 장비의 전체 장애는 매우 드물어 대부분의 애플리케이션은 하드웨어 구성 요소 중복으로 충분
        - 소프트웨어 내결함성 기술 사용하거나 하드웨어 중복성 추가해 전체 장비의 손실을 견딜 수 있는 시스템으로 이동 중
          - 장비 재부팅해야 하는 경우 중단 시간 없이 한 번에 한 노드씩 패치 가능
  - 소프트웨어 오류
    - 체계적(systematic) 오류
      - 잘못된 특정 입력이 있을 때 모든 애플리케이션 서버 인스턴스가 죽는 소프트웨어 버그. 리눅스 커널 버그 윤초 사건
      - 공유 자원 과도하게 사용하는 프로세스
      - 시스템의 속도가 느려져 반응이 없거나 잘못된 으압 반환하는 서비스
      - 한 구성 요소의 작은 결함이 다른 구성 요소의 결함으로 전파되는 연쇄 장애(cascading failure)
    - 소프트웨어에는 환경에 대한 일종의 가정이 있다
      - 대개 사실이지만 어떤 이유로 최종적으로는 사실이 아니게 된다
    - 해결책
      - 신속한 해결책이 없다
      - 시스템의 가정과 상호작용에 대해 주의 깊은 고찰
      - 빈틈없는 테스트
      - 프로세스 격리
      - 죽은 프로세스 재시작 허용
      - 프로덕션 환경에서 시스템 동작 측정, 모니터링, 분석, 지속적 확인
  - 인적 오류
    - 대규모 인터넷 서비스 연구 : 운영자의 설정 오류가 중단의 주요 원인, 하드웨어 결함은 10 ~ 25%
    - 해결책
      - 오류의 가능성을 최소화하는 방향으로 시스템 설계
        - 잘 설계된 추상화, API, 관리 인터페이스 사용
          - 옳은 일은 쉽게 하고 잘못된 일은 막을 수 있다.
      - 사람이 가장 많이 실수하는 부분에서 사람의 실수로 장애 발생할 수 있는 부분 분리
      - 실제 사용자에게 비 프로덕션 샌드박스(운영 환경이 저장소로부터 테스트되지 않은 코드 변경사항 및 전면적인 실험을 분리시키는 테스트 환경) 제공
      - 단위 테스트, 전체 시스템 통합 테스트, 수동 테스트 등 모든 수준에서 테스트, 자동 테스트
      - 인적 오류 빠르게 쉽게 복구할 수 있게
        - 설정 변경 내역 빠르게 롤백하고 새로운 코드 서서히 롤아웃 하게, 데이터 재계산 도구 제공
      - 상세하고 명확한 모니터링 대책 마련 : 성능 지표, 오류율 등
      - 조작 교육, 실습
- 신뢰성이 중요한 이유
  - 비즈니스 생산성 저하, 매출 손실 등등
  - 사용자에 대한 책임
  - 신뢰성을 희생해야 하는 상황에서는 비용을 줄여야 하는 시점 잘 알고 있어야 함
#### 확장성
- 성능 저하 흔한 이유 : 부하 증가
- "시스템이 특정 방식으로 커지면 이에 대처하기 위한 선택은 무엇인가?"
- "추가 부하를 다루기 위해 계산 자원을 어떻게 투입할까?"
부하 기술
  - 부하 매개변수(load parameter)
    - 웹 서버의 초당 요청 수, 데이터베이스의 읽기 대 쓰기 비율, 대화방의 동시 활성 사용자, 캐시 적중률 등
    - 평균 or 극단 케이스
    - 트위터
      - 트윗 작성 : 평균 초당 4.6k 요청, 피크일 때 12k 이상
      - 홈 타임라인 : 초당 300k 요청
      - 사용자당 팔로워의 분포가 팬 아웃(트랜잭션 처리 시스템에서 하나의 수신 요청을 처리하는 데 필요한 다른 서비스의 요청 수) 부하 결정 -> 핵심 부하 매개변수
성능 기술
  - 부하 매개변수 증가시키고 시스템 자원(CPU, 메모리, 네트워크 대역폭 등)은 변경하지 않으면 시스템 성능은 어떻게 될까?
  - 부하 매개변수 증가시켰을 때 성능 유지되길 바란다면 자원을 얼마나 늘려야 할까?
  - 성능 수치 필요
    - 처리량(throughput), 응답 시간(response time), 









### 7장 트랜잭션 
데이터 시스템 발생 가능 문제들
- DB 소프트웨어나 하드웨어 실패
- 애플리케이션 죽음
- 네트워크 연결 끊김 -> 애플리케이션과 DB 연결 끊길 수도, DB 노드간 통신 끊길 수도
- 여러 클라이언트가 동시에 DB에 쓰기 실행해서 덮어 쓰기
- 클라이언트가 부분적으로만 갱신돼 비정상 데이터 읽음
- 클라이언트 사이의 경쟁 조건으로 예측하지 못한 버그
잘못될 수 있는 모든 것에 대해 여러 번의 테스트 필요 -> 트랜잭션으로 단순화
트랜잭션 : 애플리케이션에서 몇 개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법
- 트랜잭션 전체가 성공(커밋)하거나 실패(어보트, 롤백)
#### ACID
- 원자성
  - ACID의 맥락에선 동시성과 관련 X
  - 일부만 처리된 후 결함이 생겼을 때 일어나는 일에 대해 설명
  - 오류 발생 시 트랜잭션 어보트하고 해당 트랜잭션에서 기록한 모든 내용을 취소하는 능력, 어보트 능력(abortability)
- 일관성
  - ACID의 맥락에선 DB가 "좋은 상태"에 있어야 한다는 것
  - 항상 진실이어야 하는 데이터에 관한 어떤 선언(불변식(inavriant))가 있다는 것.
  - 불변식이 유효한 DB에서 트랜잭션의 쓰기가 유효성을 보존한다면 불변식이 항상 만족된다고 확신 가능.
  - AID와 다르게 일관성은 애플리케이션에서 보장해야 함
    - DB에서 특정 종류 불변식 확인 가능 : 외래 키 제약 조건, 유일성 제약 조건 등
- 격리성
  - 동시에 실행되는 트랜잭션은 서로 격리된다
    - 트랜잭션은 다른 트랜잭션을 방해할 수 없다.
    - 다른 트랜잭션은 그 내용을 전부 볼 수 있든지 아무것도 볼 수 없든지
  - 직렬성 : 각 트랜잭션이 전체 DB에서 실행되는 유일한 트랜잭션인 것처럼 동작할 수 있다.
  - 여러 트랜잭션이 동시에 실행됐더라도 순차적으로 실행됐을 때 결과와 동일하도록 보장
- 지속성
  - 트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 DB가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장
  - 단일 노드 DB에선 일반적으로 데이터가 하드디스크나 SSD같은 비휘발성 저장소에 기록됐다는 뜻
  - 쓰기 전 로그(WAL)이나 비슷한 수단 동반
  - 복제 기능 있는 DB에선 데이터가 성공적으로 다른 노드 몇 개에 복사됐다는 것
다중 객체 트랜잭션
- 어떤 읽기 연산과 쓰기 연산이 동일한 트랜잭션에 속하는지 알아낼 수단이 있어야 한다.
  - RDB에선 클라이언트와 DB 서버 사이 TCP 연결 기반
    - 특정 연결 내 BEGIN TRANSACTION 문과 COMMIT 문 사이의 모든 것이 같은 트랜잭션에 속하는 것으로 간주
    - 특정 TCP 연결에 묶이지 않은 고유한 트랜잭션 식별자 사용해 연산 묶을 수 있음
  - NRDB에선 없는 경우 많음
단일 객체 쓰기
- 저장소 엔진들은 보편적으로 한 노드에 존재하는 단일 객체(키-값 쌍 같은) 수준에서 원자성과 격리성 제공하는 것이 목표
- 원자성은 장애 복구(crash recovery)용 로그로 구현 가능
- 격리성은 각 객체에 잠금 사용해 (동시에 한 스레드만 객체 접근 가능) 구현 가능
- 여러 클라이언트에서 동시에 같은 객체에 쓰려고 할 때 갱신 손실(lost update)을 방지하므로 유용
- 트랜잭션은 보통 다중 객체에 대한 다중 연산을 하나의 실행 단위로 묶는 메커니즘
다중 객체 트랜잭션의 필요성
- 많은 경우 다중 객체에의 쓰기 작업이 코디네이션 돼야 함
- 예시
  - RDBMS에서 참조가 유효하도록 보장
    - 참조 키는 올발라야 하고 최신 정보를 반영해야 함
  - NRDMBS에서 비정규화 정보 갱신 시 동기화 유지 위해
  - DB 색인 갱신
오류와 어보트 처리
- 어보트된 트랜잭션 재시도의 문제점
  - 트랜잭션 성공했지만 클라이언트에게 알리기 전 네트워크 끊겼을 때
    - 애플리케이션에 추가적인 중복 제커 메커니즘 필요
  - 오류과 과부하 때문이면 재시도는 문제 악화
    - 재시도 횟수 제한, 지수적 백오프, 과부하 오류 별도 처리
  - 일시적 오류(교착 상태, 격리성 위반, 일시적 네트워크 단절, 장애 복구 등)만 재시도 가치 있고, 영구적 오류(제약 조건 위반 등)에는 무가치
  - 트랜잭션이 DB 외부에 부수 효과 있을 시 트랜잭션이 어보트될 때도 부수 효과 실행될 수 있음
    - 2단계 커밋
  - 클라이언트 프로세스가 재시도 중에 죽을 수 있음 -> DB에 쓰려 했던 모든 데이터 손실
#### 완화된 격리 수준
- 동시성 문제(경쟁 조건)
  - 하나의 트랜잭션이 다른 트랜잭션에서 동시에 변경한 데이터를 읽거나
  - 두 트랜잭션이 동시에 같은 데이터 변경 시도 시에만 나타남
  - 타이밍이 안 좋을 때만 발생하므로 테스트 어렵고 추론 어려움
- 오랫동안 DB에선 트랜잭션 격리 제공
- 직렬성 격리는 성능 비용 발생, 원치 않음
  - 완화된 격리 수준 : 어떤 동시성 이슈로부턴 보호,모든 이슈로부터는 X
    - 더 어렵고 미묘한 버그 유발 가능
    - 금전적 손실 발생시켰음, 재무 감사원 조사, 고객 데이터 오염
- 도구에 의존하기보다 존재하는 동시성 문제 종류 이해하고 방지하는 방법 배워야 함
  - 발생할 수 있는, 없는 경쟁 조건 살펴 보고 적합한 격리 수준 선택
  - 격리성 수준은 비공식적

#### 커밋 후 읽기(read committed)
- 가장 기본적인 준의 트랜잭션 격리
- DB에서 읽을 때 커밋된 데이터만 보게 된다(Dirty Read 없음)
- DB에 쓸 때 커밋된 데이터만 덮어쓰게 된다(Dirty Write 없음)
- 더티 읽기 방지
  - 더티 읽기 : 썼지만 트랜잭션 완료되지 않은 데이터 보는 것
  - 트랜잭션이 쓴 내요은 커밋된 후에야 다른 트랜잭션에게 보임
- 더티 쓰기 방지
  - 두 트랜잭션이 동일한 객체 동시 갱신 시 원치 않는 결과 발생 가능
커밋 후 읽기 구현
- 더티 쓰기 방지 
  - 흔한 방법 : 객체(로우나 문서)에 대해 갱신 원할 시 그 객체에 대한 잠금 획득하고 보유하고 있어야 함
    - 한 트랜잭션만 가능
    - 이 레벨 이상의 DB에서 자동으로 실행
- 더티 읽기 방지
  - 그 잠금을 획득해야 읽을 수 있도록 하는 방법
    - 오래 걸리는 쓰기가 완료될 때까지 읽기들이 기다려야 함
  - 모든 객체는 커밋 값과 쓰기 잠금 트랜잭션에서 쓴 새로운 값 모두 기억
#### 스냅숏 격리
- 비반복 읽기(nonrepeatable read)나 읽기 스큐(read skew(시간적 이상현상, timing anomaly)
  - 잔액 다른 값 볼 수 있지만 쓰기 트랜잭션 끝난 후에 읽으면 정상
- 커밋 후 읽기 격리에서 받아들일 수 있는 것으로 여겨짐
- 이런 일시적 비일관성 감내할 수 없는 경우 존재
  - 백업하는 동안 쓰기 하면 백업의 일부는 과거 버전, 일부는 새 버전
  - 이 백업 쓰면 비일관성이 영속적이게 됨
- 분석 질의와 무결성 확인
  - 무결성 확인 시 다른 시점의 DB 보면 불합리한 결과 반환할 수도
- 스냅숏 격리는 이런 문제의 가장 흔한 해결책
  - 각 트랜잭션은 DB의 일관된 스냅샷으로부터 읽음
  - 데이터가 나중에 바뀌어도 각 트랜잭션은 특정한 시점의 과거 데이터 봄
  - 백업이나 분석처럼 실행하는 데 오래 걸리며 읽기만 실행하는 질의에 유용
  - MySQL, Oracle, SQL server 등에서 지원
스냅숏 격리 구현
- 쓰기 잠금 사용
- 읽을 땐 잠금 사용 X
- 읽기, 쓰기가 서로 차단하지 않는 것이 성능적 관점에서의 핵심
- DB는 객체마다 커밋된 버전 여러 개 유지해야 함
- 다중 버전 동시성 제어(multi-version concurrency control, MVCC)
- 커밋 후 읽기 격리에서도 버전 두 개면 충분하지만 MVCC 사용
일관된 스냅숏을 보는 가시성 규칙
1. DB는 트랜잭션 시작 시 그 시점에 진행 중인 모든 트랜잭션 목록 만듦
  - 이 트랜잭션들이 쓴 데이터는 모두 무시
2. 어보트된 트랜잭션이 쓴 데이터 모두 무시
3. 트랜잭션 ID가 더 큰 트랜잭션이 쓴 데이터는 커밋 여부 관계 없이 무시
4. 그 밖의 모든 데이터는 애플리케이션 질의로 볼 수 있음
- 객체 생성과 삭제 모두에 적용
- created_by, deleted_by 필드 생성
- 아무 트랜잭션도 더 이상 삭제요청된 데이터에 접근하지 않는 게 확실해지면 DB 가비지 컬렉션 프로세스가 해당 로우들 삭제
- SQL 표준 스냅숏 격리 개념 없음
  - Oracle에서는 직렬성, MySQL에서는 반복 읽기(repeatable read)
  - SQL 표준 격리수준에는 결함 있음
    - 모호하고 부정확
    - 구현 독립적이지 않음
#### 갱신 손실(lost update) 방지
- 갱신 손실(lost update) : 쓰기 쓰기 충돌(write-write conflict) 중 가장 널리 알려짐
- 애플리케이션이 DB 읽고 변경 후 쓸 때 (read-modify-write 주기)
- 예시
  - 카운터 증가, 계좌 잔고 갱신
  - 복잡한 값 지역적으로 변경. JSON 리스트에 엘리먼트 추가
  - 위키 두 명 동시 편집
- 해결책
  - 원자적 쓰기 연산
    - DB에서 연산 제공, JSON 파싱 등의 원자적 연산 제공
    - 커서 안정성(cursor stability)
      - 객체에 독점적인(exclusive) 잠금 획득해서 구현
      - 갱신 완료 시까지 다른 트랜잭션이 그 객체 못 읽음
    - 모든 원자적 연산을 단일 스레드에서 실행되도록 강제
    - 객체 관계형 매핑 프레임워크 사용 시 DB 제공 원자적 연살 대신 불안전한 read-modify-write 주기 실행하는 코드 작성하기 쉬움
  - 명시적 잠금
    - 애플리케이션에서 갱신할 객체를 명시적으로 잠금
    - ```BEGIN TRANSACTION; ... FOR UPDATE;``` 사용하면 DB는 질의로 반환된 모든 로우에 대해 잠금을 획득해야 함
    - 이후 ```COMMIT;```
  - 갱신 손실 자동 감지
    - 병렬 실행 허용
    - 트랜잭션 관리자가 갱신 손실 감지
    - 해당 트랜잭션 어보트 후 read-modify-write 주기 재시도하도록 강제
    - 오라클의 직렬성, SQL 서버의 스냅숏 격리 수준은 갱신 손실 자동 감지, MySQL/이노DB의 반복 읽기는 감지 X
    - 애플리케이션 코드에서 특별한 DB 기능 쓸 필요 없게 도와줌
    > .. FOR UPDATE 절 같은 기능 말하는 건가?
    > 어떤 DBMS가 어느 수준 격리 제공하는 지 확인 후에 이런 부분은 세부적 조사 필요할 듯
    > 어떻게 감지하지?
  - Compare-and-set
    - 값을 마지막으로 읽은 후 변경되지 않았을 때만 갱신 허용
    - 다르면 R-M-W 주기 재시도해야 함
    - 갱신 적용됐는지 확인 필요, 안 됐으면 재시도
    ```sql
    UPDATE wiki_pages SET content = 'new content'
    WHERE id = 1234 AND content = 'old content';
    ```
    - 갱신 손실 항상 방지 X
      - WHERE절이 오래된 스냅숏 읽는 것 허용한다면?
  - 충돌 해소와 복제
    - 복제 적용된 DB에서 추가 단계 필요
    - 여러 쓰기가 동시에 실행되고 비동기식 복제 허용
    - 한 값에 대해 여러 개의 충돌된 버전(형제(sibling)) 생성 허용
    - 사후 애플리케이션 코드나 데이터 구조 활용해 충돌 해소, 병합
#### 쓰기 스큐와 팬텀
- 호출인원 2명인 상황에서 의사 두 명이 동시에 대기인원 조회 후 대기 이탈하면 호출인원 0명 됨.
쓰기 스큐 특징짓기
- 이 경우도 경쟁 조건
- 두 객체에 대한 갱신
- 같은 객체들을 읽어서 그 중 일부를 갱신할 때 나타날 수 있음
- 동일한 객체 갱신인 경우 더티 쓰기나 갱신 손실 이상
- MySQL 반복 읽기, 오라클 직렬성, SQL 서버 스냅숏 격리 수준에서 자동 감지 안 됨.
- 자동 방지 위해선 진짜 직렬성 격리 필요
- DB에서의 제약 조건 구현 가능한 곳도 있음
- 직렬성 격리 수준 사용할 수 없다면 로우를 명시적으로 잠그는 것이 차선책
쓰기 스큐 4가지 예시 : p249
쓰기 스큐를 유발하는 팬텀
- 모든 예는 비슷한 패턴을 따른다
1. SELECT 질의가 어떤 검색 조건에 부합하는 로우를 검색함으로써 어떤 요구사항을 만족하는지 확인(두 명의 의사 대기 중)
2. 질의 결과에 따라 애플리케이션 코드는 어떻게 진행할 지 결정(해당 연산 계속할 지, 오류 보고할 지)
3. 계속하기로 했다면 DB에 쓰고 트랜잭션 커밋
- 팬텀(phantom) : 어떤 트랜잭션에서 실행한 쓰기가 다른 트랜잭션의 검색 질의 결과를 바꾸는 효과

충돌 구체화
- 잠글 수 있는 객체가 없다면 잠금 객체 추가 가능
> 구체적으로 이게 왜 문제가 되는 지 생각해 보기
- 동시성 제어 메커니즘이 애플리케이션 데이터모델로 파생되는 것 비권장 -> 최후의 수단


#### 직렬성
- 여러 트랜잭션이 병렬로 실행되더라도 최종 결과는 동시성 없이 한 번에 하나씩 직렬로 실행될 때와 같도록 보장
- 대부분 3가지 기법 중 하나
  - 실제적 순차적 실행
  - 2단계 잠금
  - 낙관적 동시성 제어(optimistic concurrency control)
  - 우선 단일 노드 DB 기준 설명
실제적 직렬 실행
- 트랜잭션 하나씩만 직렬로 단일 스레드에서 실행
- 가능케 한 원인 2 가지
  - 램 가격 저렴해져 데이터셋 전체를 메모리에 유지 가능
  - OLTP 트랜잭션이 짧고 읽기, 쓰기 개수가 적다
  - 오래 실행되는 분석 질의는 직렬 실행 루프 밖에서 일관된 스냅숏 사용하면 된다.
- 처리량이 CPU 코어 하나의 처리량으로 제한
트랜잭션을 스토어드 프로시저 안에 캡슐화
- 모든 과정을 트랜잭션에 포함하는 시도
- 단일 스레드 트랜잭션 순차 처리 시스템들은 상호작용 다중 구문 트랜잭션 허용 안 함
- 애플리케이션은 트랜잭션 코드 전체를 스토어드 프로시저 형태로 DB에 미리 제출
- 필요한 데이터는 모두 메모리에 있고 스토어드 프로시저는 매우 빨리 실행된다고 가정(네트워크, 디스크 I/O 없이)
- 현대 스토어드 프로시저는 기존의 범용 프로그래밍 언어 사용
파티셔닝
- 순차 실행은 쓰기 처리량 높은 애플리케이션에게 심각한 병목이 될 수도
- 각 트랜잭션이 단일 파티션 내에서만 데이터 읽고 쓰도록 데이터셋 파티셔닝
  - 각 파티션은 자신만의 트랜잭션 처리 스레드 할당 가능
  - 트랜잭션 처리량을 CPU 코어 개수에 맞춰 선형적 확장 가능
- 여러 파티션에 접근하는 트랜잭션
  - 해당 모든 파티션에 걸쳐 코디네이션 필요
  - 해당 모든 파티션에 잠금 획득 후 실행
  
2단계 잠금(2PL)
- 쓰려고 하면 독점적 접근 필요
- 쓰기 트랜잭션은 다른 쓰기, 읽기 트랜잭션 진행하지 못하게 막고 역도 성립
- 직렬성 제공
- 공유 모드(shared mode), 독점 모드(exclusive mode) 잠금
  - 읽기 원하면 공유 모드 잠금 획득
  - 쓰기 원하면 독점 모드 잠금 획득
  - 잠금 획득 후에는 트랜잭션이 종료될 때까지 잠금 유지해야 함
- 교착 상태 발생 가능
  - 자동 감지 후 하나 어보트, 재시도
- 서술 잠금(predicate lock)
  - 검색 조건에 부합하는 모든 객체에 속함
  - 미래에 추가될 수 있는 객체(팬텀)에도 적용 가능
- 색인 범위 잠금
  > 추후 파악 필요
  
직렬성 스냅숏 격리(serializable snapshot isolation, SSI)
- 완전한 직렬성 제공
- 단일 노드, 분산 노드 DB 모두에서 사용
비관적 동시성 제어 대 낙관적 동시성 제어
- 비관 : 잘못될 가능성이 있으면 뭔가 하기 전에 안전해 질 때까지 기다림
- 낙관 : 트랜잭션을 막는 대신 모든 것이 괜찮아질 거라는 희망으로 계속 진행
- SSI는 낙관적 동시성 제어 기법
- 경쟁은 가환(commutative) 원자적 연산을 통해 줄임
- 스냅숏 격리 위에 쓰기 작업 사이의 직렬성 충돌 감지하고 어보트시킬 트랜잭션 결정하는 알고리즘 추가
- 뒤쳐진 전제에 기반한 결정
  - 뒤쳐진 전제 기반 동작 감지하고 트랜잭션 어보트
  - 질의 결과가 바뀌었는 지 확인하는 방법
    - 오래된 MVCC 객체 버전을 읽었는지 감지(읽기 전에 커밋되지 않은 쓰기 발생)
      - 트랜잭션 커밋 시 무시된 쓰기 중 커밋된 게 있는 지 확인
    - 과거의 읽기에 영향을 미치는 쓰기 감지(읽은 후 쓰기 감지)

